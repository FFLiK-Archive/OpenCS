---
layout: default
title: Theme 2. Function
parent: Lectures
nav_order: 2
nav_exclude: false
---
### Theme 2
{: .no_toc }
# Function
{: .no_toc }
- - -         
## Contents
{: .no_toc .text-delta }
1. TOC
{:toc}
- - -     

## 함수란?          
> y = f(x)          

이것이 바로 수학에서 흔히 사용하는 **"함수"**입니다.            
프로그래밍에서도 마찬가지입니다.            

{: .highlight }         
함수는 어떤 입력값(들)을 적절히 연산하여 출력값을 만들어내는 코드 묶음입니다.            

## 함수의 정의            
어떤 함수를 만드는 것을 **"함수를 정의한다"**라고 부릅니다.             
따라서 함수는 아래와 같이 정의할 수 있습니다.        

```python
def function_name():
    #function code
    return
```

> `def` : 함수를 정의한다는 의미의 파이썬 키워드입니다.            
> `function_name` : 함수의 이름입니다.              
> `return` : 함수를 종료시키는 파이썬 키워드입니다. (물론 엄밀하게는 다른 의미입니다.)          
단, 여기서 `return`은 반환값이 없는 경우 **생략** 가능합니다. (반환값에 대해서는 아래에서 다루겠습니다.)            

{: .warning }
> 함수명은 다음과 같은 **조건**을 만족해야합니다.         
> 1. 특수 문자는 언더바(_)만 허용합니다.         
> 2. 공백을 포함하면 안 됩니다. (언더바로 대체하세요)          
> 3. 파이썬 키워드를 사용하면 안 됩니다. (ex return, int ...)           
> 4. 숫자로 함수명을 시작할 수 없습니다.          
>           
> + 함수명은 웬만하면 **영어**로, **간결하지만 직관적**이게 작성하세요.     
> + 함수명을 중복하여 사용하지 마세요.    

`#function code` 부분에는 **그 함수가 어떤 행동을 할지** 정의할 수 있습니다.            
이 공간은 그 함수만을 위한 공간으로, 그 함수 내부에서 사용된 변수는 외부의 어떤 것과도 상호 작용하지 않습니다.           
따라서 아래와 같은 코드에서         

```python
a = 10
def f():
    a = 0
f()
```
언뜻 보면 a가 0으로 바뀌었을 것 같지만, 외부에 정의된 a는 여전히 10입니다. (직접 출력해보세요.)           


{: .warning}
함수 내부의 내용 (`return` 포함)은 무조건 함수의 정의 부분 (`def function_name():`) 보다            
**한 번 들여써야** 합니다. (tab 키로 들여쓸 수 있습니다.)     
```python
def f():
    <함수 내용1>
    <함수 내용2>
    <함수 내용3>
    ...
<함수 외부>
```

이것이 아주 **기본적인 파이썬 함수**의 형태입니다.          
하지만 함수는 앞에서 언급했듯 **출력값**을 만들어낼 수 있습니다. (f(x)에서 f(x)가 의미하는 값 같은 역할)           
여기서 `return`의 새로운 기능이 등장합니다.         

```python
return return_value
```

`return`을 통해 **어떤 값을 반환하고 (뱉어내고) 함수를 종료시킬 수 있습니다.**         
즉 아무것도 없이 `return`을 쓰면 이는 즉 아무것도 반환하지 않고 종료한다는 의미입니다.    

여러 언어들은 반환값을 하나만 허용하지만, 파이썬은 예외적으로 여러개의 반환값을 허용합니다.         

```python
return return_value_1, return_value_2, return_value_3 ...
```

참고로 이를 대입받을 때에는 아래와 같이 쓸 수 있습니다.         

```python
a, b, c, ... = function()
```

함수는 **입력값**을 받아올 수 있습니다. (마치 f(x)의 x같은 역할)            
이를 프로그래밍 용어로 **"매개 변수(parameter)"**라고 부릅니다.

```python
def function_name(parameter1, parameter2, ...) :
```
            
매개 변수는 여러 개를 받아올 수 있습니다.            
(매개 변수는 변수입니다. 따라서 변수명 조건을 따른다면 자유롭게 설정할 수 있습니다.)            
이렇게 받아온 매개변수는 함수 내에서 자유롭게 활용할 수 있습니다.           

## 함수의 사용
아래의 함수는 받아온 2개의 매개 변수를 서로 더하여 반환하는 함수입니다.         

```python
def add(a, b):
    return a + b
```         

이 함수는 함수 자기 자신 밖에서 아래와 같이 사용할 수 있습니다.       
이러한 과정을 **"함수를 호출한다"**라고 부릅니다.    

```python
result = add(3, 5)
```

즉, 위 코드는 아래와 똑같은 코드입니다.         

```python
result = 3 + 5
```

{: .note}
**서로 다른 함수라면 어떤 함수 안에서 다른 함수를 호출해도 아무 문제가 없습니다.**          
하지만 어떤 함수 안에서 그 함수 자기 자신을 호출하면 매우 특이한 현상이 일어납니다.            
이건 13차시의 재귀 (Recursion) 파트에서 알아봅시다.         
(참고로 재귀는 CS1 범위 밖의 내용입니다.)           

{: .warning}
함수를 사용하기 위해서는 **위에 반드시 그 함수가 정의되어 있어야 합니다.**          
오류 코드 : NameError: name '[함수명]' is not defined           

## 함수의 필요성        
그렇다면 이러한 함수는 어째서 필요할까요?       
함수는 **여러번 쓰이는 어떤 기능을 매우 간편하게 사용**할 수 있도록 해줍니다.           
원래였으면 어떤 코드를 그대로 복붙하여 여러번 써야했겠지만,         
이를 함수로 만들어놓으면, 필요할 때 함수만 호출하면 그 코드를 복붙해놓은 것 같은 효과를 줍니다.          
또한, 그 기능을 수정해야할 때, 함수 내용만 바꾸면 그 함수가 쓰인 모든 부분이 한꺼번에 바뀌는 효과를 낼 수 있습니다.         

이와 더불어 코드를 기능적으로 분류해 함수화 해놓으면 **코드가 덜 복잡**해집니다.         
코드는 그 자체가 의미하는 바를 해석하기 난해한 경우가 굉장히 많습니다. (그래서 주석을 사용합니다)               
하지만 함수를 활용하면, 이 난해한 코드를 묶어 적절한 함수명을 통해 직관적으로 바꿀 수 있습니다.         

말로 표현해봤자 함수의 중요성을 알려주기는 힘듭니다.            
함수의 강력함은 직접 활용하며 깨닫길 바랍니다.          

## Call By Assignment
이 내용은 CS1에서 다루지는 않지만           
문제를 풀다가 분명히 실수할 것 같아 넣었습니다.         
(편하게 읽고 넘어가세요)            

```python
a = 0
def add1(x): #입력된 x의 값을 1 증가시키는 함수
    x += 1
add1(a) #a에 1을 더하기 위해 add1 함수 호출
print(a)
```
언뜻 보면 1이 출력될 것 같습니다.
하지만 **실제로 출력해보면 출력값은 0(!!!)**입니다.

그렇지만 만약에 x가 int타입 변수 (정수 타입 변수)가 아닌            
list (9주차 내용), class 객체 (CS2 내용), dict, set 같은 변수였다면         
저런 코드로 그 값을 바꿀 수 있습니다.           

이것은 파이썬이 **Call By Assignment**라는 체계를 사용하기 때문입니다.          
이 체계는 마치 **int, float, str 등은 Call By Value**,           
**list, class 객체 등은 Call By Reference** 체계처럼 동작합니다.            
물론 엄밀하게 말하면 진짜로 Call By Value 또는 Call By Reference 인 것은 아닙니다.         
하지만 파이썬의 메모리 관리 체계 때문에 위 방식과 비슷하게 동작하죠.        

1. **Call By Value**            
이 방식은 매개 변수에 값을 전달 할 때            
**오직 그 값만 전달합니다.**        
즉, 위 코드에서는 a를 전달한게 아닌, a에 들어있는 값만 전달해서         
그 값을 그대로 x에 넣고 x값을 바꾼겁니다.           
x와 a는 독립적이니 결론적으로 a는 바뀌지 않습니다.      

2. **Call By Reference**            
이 방식은 매개 변수에 값을 전달 할 때            
**그 변수 자체를 전달합니다.**        
즉, 위 같은 상황에서는 a라는 변수로 x를 통째로 치환해버렸다고 생각하면 편합니다.         
그러니 x가 바뀌면 x는 a를 의미하니 원본인 a도 바뀝니다.         

이렇게 복잡한 방식을 사용하는 이유는            
파이썬의 **메모리 관리** 방식 때문입니다.         
더 깊은 내용이 궁금하다면 멘토한테 물어보거나 <a href = "https://engkimbs.tistory.com/667">이 게시글</a>을 참고하세요.          

## Math Module
복잡한 수학적 연산은 지금까지 배운 연산자로는 해결할 수 없습니다.           
이를 해결하는 방법을 소개해드리도록 하겠습니다.         

```python
import math
```
심화된 수학 연산 기능을 활용하기 위해서는 `math`라는 모듈을 임포트 해야합니다.

{: .note}
모듈은 어떤 기능들 (함수, class 객체 등)을 정리하여 모아둔 것을 의미합니다.         

> math가 제공하는 함수 형태의 연산자          
> - 제곱근 : `y = math.sqrt(x)`
> - 삼각 함수 : `y = math.sin(x)`, `y = math.cos(x)`, `y = math.tan(x)` 등 (역삼각함수도 지원)
> - 자연 로그 : `y = math.log(x)`
> - 상용 로그 : `y = math.log10(x)`
> - 내림 : `y = math.floor(x)`
> - 올림 : `y = math.ceil(x)`
> - 반올림 : `y = math.round(x)`            
> <a href = "https://docs.python.org/ko/3/library/math.html">[추가 내용]</a>

math 모듈은 아니지만 알아두면 좋은 함수 형태의 연산자
> - 절댓값 : `y = abs(x)`